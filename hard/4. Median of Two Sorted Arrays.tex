给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

































思路：
直接法。



































code：
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int x = 0, y = 0;
        vector<int> res;
        while(x < nums1.size() && y < nums2.size())
        {
            if(nums1[x] < nums2[y])
            {
                res.push_back(nums1[x]); x++;
            }
            else if((nums1[x] == nums2[y]))
            {
                res.push_back(nums1[x]); x++;
                res.push_back(nums2[y]); y++;
            }
            else
            {
                res.push_back(nums2[y]); y++;
            }
        }
        while(x < nums1.size())
        {
            res.push_back(nums1[x]); x++;
        }
        while(y < nums2.size())
        {
            res.push_back(nums2[y]); y++;
        }
        double result = 0;
        int size = res.size();
        if(size % 2 == 1) result = res[size/2];
        else result = ((double)res[size/2-1] + (double)res[size/2])/2;
        return result;
    }
};